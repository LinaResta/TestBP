{
  "$type": "Comindware.Platform.Contracts.UserCommandConfigurationModel, Comindware.Platform.Contracts",
  "GlobalAlias": {
    "$type": "Comindware.Platform.Contracts.GlobalAlias, Comindware.Platform.Contracts",
    "Type": "UserCommand",
    "Owner": "ProcessingWorkItem",
    "Alias": "editTask"
  },
  "Name": "Сохранить",
  "IsSystem": false,
  "IsDisabled": false,
  "IsPrepare": false,
  "SkipValidation": false,
  "Context": "Record",
  "Multiplicity": "OneByOne",
  "Kind": "Script",
  "ResultType": "DataChange",
  "ScriptRule": {
    "$type": "Comindware.Platform.Contracts.UserCommandScriptRuleModel, Comindware.Platform.Contracts",
    "Type": "UserCommandScript",
    "Definition": {
      "$type": "Comindware.Platform.Contracts.CSharpRuleDefinitionModel, Comindware.Platform.Contracts",
      "EntryPoint": "Script",
      "Code": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing Comindware.Data.Entity;\r\nusing Comindware.TeamNetwork.Api.Data;\r\nusing Comindware.TeamNetwork.Api.Data.UserCommands;\r\nusing Newtonsoft.Json;\r\nusing System.Net;\r\nusing System.IO;\r\nusing System.Text;\r\nusing System.Diagnostics;\r\nclass Script { \r\n\r\n    public static UserCommandResult Main(UserCommandContext context, Comindware.Entities entities) {      \r\n \r\n        // получим id текущей задачи\r\n        var rootRecordId = context.ObjectIds[0];\r\n        \r\n        // получим id работы, к которой была привязана задача\r\n        var workItemId = Api.TeamNetwork.UserTaskService.GetBusinessObject(rootRecordId); \r\n  \r\n        // проверим, что на работу есть назначенные исполнители в NaznachIspolnitel\r\n        // если их нет, то ничего не делаем \r\n        var NaznachIspolnitel = entities.Workitem.Where(x => x.id == workItemId).Select(x => new { x.NaznachIspolnitel }).FirstOrDefault().NaznachIspolnitel;\r\n        if (NaznachIspolnitel.Count() == 0) {\r\n            // В назначенных исполнителях никого нет!\r\n            return new UserCommandResult {\r\n                Success = true,\r\n                Commited = true,\r\n                ResultType = UserCommandResultType.DataChange,\r\n                Messages = new[] {\r\n                    new UserCommandMessage {\r\n                        Severity = SeverityLevel.Normal,\r\n                        Text = \"\"\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        \r\n        // проверим, совпадают ли назначенные исполнители и обычные исполнители\r\n        var Performers = entities.Workitem.Where(x => x.id == workItemId).Select(x => new { x.Performers }).FirstOrDefault().Performers;      \r\n        if (NaznachIspolnitel.Count() == Performers.Count()) {            \r\n            var equals = 1;\r\n            // проверим, совпадают ли они один в один\r\n            foreach (var nazn in NaznachIspolnitel) {\r\n                if (Performers.Contains(nazn)) { \r\n                    continue;\r\n                }\r\n                equals = 0; // если дошли до сюда, то они не совпадают по участникам\r\n            }\r\n            \r\n            if (equals == 1) {\r\n                // Новые и старые исполнители совпадают, ничего не делаем! \r\n                return new UserCommandResult {\r\n\t                Success = true,\r\n\t                Commited = true,\r\n\t                ResultType = UserCommandResultType.DataChange,\r\n\t                Messages = new[] {\r\n\t                    new UserCommandMessage {\r\n\t                        Severity = SeverityLevel.Normal,\r\n\t                        Text = \"\"\r\n\t                    }\r\n\t                }\r\n\t            };\r\n            }\r\n        }\r\n\r\n        // если дошли до сюда, то у нас точно NaznachIspolnitel не равны Performers\r\n        // а значит нужно остановить процесс выполнения работы\r\n        // найдем процессы по работе \r\n        var activeProcesses = Api.Process.ProcessObjectService.GetReferencedProcesses(workItemId).ToList(); \r\n        foreach (var singleProc in activeProcesses) {\r\n            // завершим каждый найденный активный родительский процесс\r\n            if (singleProc.Status.ToString() == \"Active\" && singleProc.ParentId == null) {\r\n               Api.Process.ProcessObjectService.CancelProcess(singleProc.Id);\r\n            }\r\n        }\r\n        \r\n        // изменим данные по задаче - cкопируем NaznachIspolnitel в Performers\r\n        var taskData = new Dictionary<string, object> {\r\n            { \"Performers\", NaznachIspolnitel } ,\r\n            { \"whoChangedPerformers\", context.CurrentUserId} ,\r\n            { \"Performers_Text_History\", \"\"}            \r\n        }; \r\n        Api.TeamNetwork.ObjectService.EditWithAlias(\"Workitem\", workItemId, taskData);\r\n\r\n        var planId = entities.Workitem.Where(x => x.id == workItemId).Select(x => new { x.PlanWork, x.parentProject }).FirstOrDefault().PlanWork;\r\n        var projectId = entities.Workitem.Where(x => x.id == workItemId).Select(x => new { x.PlanWork, x.parentProject }).FirstOrDefault().parentProject;\r\n                \r\n        // если не нашли план работ, то найдем проект, к которому привязана работа\r\n        //var team = entities.ProjectTeam.Where(x => x.WorkPlan == \"XXXX\").Select(x => new { x.id, x.Performers }).FirstOrDefault();\r\n        //if (planId != null) {\r\n        //    team = entities.ProjectTeam.Where(x => x.WorkPlan == planId).Select(x => new { x.id, x.Performers }).FirstOrDefault();\r\n        //} else if (projectId != null) {\r\n        //    team = entities.ProjectTeam.Where(x => x.Project == projectId).Select(x => new { x.id, x.Performers }).FirstOrDefault();\r\n        //}\r\n\r\n        // присоединим новых людей из назначенных исполнителей к проектной команде\r\n        foreach (var nazn in NaznachIspolnitel) {\r\n            if (Performers.Contains(nazn)) { \r\n                continue;\r\n            }\r\n            // определим орг.единицу нового человека из справочника пользователей\r\n            var loginAD = Api.Base.AccountService.GetAccount(nazn).Username;\r\n\t\t\tvar organisation = entities.Users.Where(x => x.SNG_LOGIN == loginAD).Select(x => new { x.WERKS_TEXT, x.OE }).FirstOrDefault();\r\n            \r\n            var teamData = new Dictionary<string, object> {\r\n                {\"Role\", \"786547\"},\r\n                {\"Performers\", nazn},\r\n                {\"Project\", projectId},\r\n                {\"OrgEd\", organisation.WERKS_TEXT + \" \" + organisation.OE},\r\n                {\"WorkPlan\", planId}\r\n            };\r\n            Api.TeamNetwork.ObjectService.CreateWithAlias(\"ProjectTeam\", teamData);\r\n        }\r\n        \r\n        // запустим новый процесс по задаче\r\n        Api.Process.ProcessObjectService.CreateWithObjectId(\"pa.9\", null, workItemId, 1);\r\n                \r\n        return new UserCommandResult {\r\n            Success = true,\r\n            Commited = true,\r\n            ResultType = UserCommandResultType.DataChange,\r\n            Messages = new[] {\r\n                new UserCommandMessage {\r\n                    Severity = SeverityLevel.Normal,\r\n                    Text = \"Выполнено\"\r\n                }\r\n            }\r\n        };\r\n    }\r\n}",
      "Type": "CSharpExpression"
    }
  },
  "RelatedEntityGlobalAlias": {
    "$type": "Comindware.Platform.Contracts.GlobalAlias, Comindware.Platform.Contracts",
    "Type": "Undefined"
  },
  "LockStateChangeType": "Undefined",
  "LockStateVisibilityType": "Undefined"
}