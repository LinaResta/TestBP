{
  "$type": "Comindware.Platform.Contracts.UserCommandConfigurationModel, Comindware.Platform.Contracts",
  "GlobalAlias": {
    "$type": "Comindware.Platform.Contracts.GlobalAlias, Comindware.Platform.Contracts",
    "Type": "UserCommand",
    "Owner": "WorkPlan",
    "Alias": "PlanConsTask"
  },
  "Name": "Сформировать задание DIRECTUM",
  "IsSystem": false,
  "IsDisabled": false,
  "IsPrepare": false,
  "SkipValidation": false,
  "Context": "Record",
  "Multiplicity": "OneByOne",
  "Kind": "ExportObject",
  "ResultType": "File",
  "ScriptRule": {
    "$type": "Comindware.Platform.Contracts.UserCommandScriptRuleModel, Comindware.Platform.Contracts",
    "Type": "UserCommandScript",
    "Definition": {
      "$type": "Comindware.Platform.Contracts.CSharpRuleDefinitionModel, Comindware.Platform.Contracts",
      "EntryPoint": "Script",
      "Code": "using System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Linq;\r\nusing System.Text.RegularExpressions;\r\nusing Comindware.Data.Entity;\r\nusing Comindware.TeamNetwork.Api.Data.UserCommands;\r\nusing System.IO;\r\n    \r\npublic class NaturalSortComparer : IComparer<string>, IDisposable\r\n{\r\n    private bool isAscending;\r\n\r\n    public NaturalSortComparer(bool inAscendingOrder = true) {\r\n        this.isAscending = inAscendingOrder;\r\n    }\r\n\r\n    #region IComparer<string> Members\r\n\r\n    public int Compare(string x, string y) {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    #endregion\r\n\r\n    #region IComparer<string> Members\r\n\r\n    int IComparer<string>.Compare(string x, string y) {\r\n        if (x == y) {\r\n            return 0;\r\n        }\r\n\r\n        string[] x1, y1;\r\n\r\n        if (!table.TryGetValue(x, out x1)) {\r\n            x1 = Regex.Split(x.Replace(\" \", \"\"), \"([0-9]+)\");\r\n            table.Add(x, x1);\r\n        }\r\n\r\n        if (!table.TryGetValue(y, out y1)) {\r\n            y1 = Regex.Split(y.Replace(\" \", \"\"), \"([0-9]+)\");\r\n            table.Add(y, y1);\r\n        }\r\n\r\n        int returnVal;\r\n\r\n        for (int i = 0; i < x1.Length && i < y1.Length; i++) {\r\n            if (x1[i] != y1[i]) {\r\n                returnVal = PartCompare(x1[i], y1[i]);\r\n                return isAscending ? returnVal : -returnVal;\r\n            }\r\n        }\r\n\r\n        if (y1.Length > x1.Length) {\r\n            returnVal = 1;\r\n        } else if (x1.Length > y1.Length) {\r\n            returnVal = -1;\r\n        } else {\r\n            returnVal = 0;\r\n        }\r\n\r\n        return isAscending ? returnVal : -returnVal;\r\n    }\r\n\r\n    private static int PartCompare(string left, string right) {\r\n        int x, y;\r\n        if (!int.TryParse(left, out x))\r\n            return left.CompareTo(right);\r\n\r\n        if (!int.TryParse(right, out y))\r\n            return left.CompareTo(right);\r\n\r\n        return x.CompareTo(y);\r\n    }\r\n\r\n    #endregion\r\n\r\n    private Dictionary<string, string[]> table = new Dictionary<string, string[]>();\r\n\r\n    public void Dispose() {\r\n        table.Clear();\r\n        table = null;\r\n    }\r\n}\r\n\r\n\r\n\r\npublic static class Script {\r\n\r\n    public static UserCommandResult ShowError(string text) {\r\n        if (text == null) {\r\n            text = \"ОК\";\r\n        }\r\n        return new UserCommandResult {\r\n            Success = false,\r\n            Commited = false,\r\n            ResultType = UserCommandResultType.Notificate,\r\n            Messages = new[] {\r\n                new UserCommandMessage {\r\n                    Severity = SeverityLevel.Normal,\r\n                    Text = text\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    public static UserCommandResult Main(UserCommandContext userCommandContext, Comindware.Entities entities) {\r\n        // прочитаем id плана работ из которого будем делать задание\r\n        var rootRecordId = userCommandContext.ObjectIds[0];\r\n\r\n        // прочитаем даты на которые нам нужно сформировать задание\r\n        var planData = entities.WorkPlan.Where(x => x.id == rootRecordId).Select(x => new { x.TaskDateFrom, x.TaskDateTo, x.Cost_Surgut, x.Cost_Izhevsk}).FirstOrDefault();\r\n\r\n        if (planData.TaskDateFrom == null || planData.TaskDateTo == null) {\r\n            return ShowError(\"Укажите период формирования задания\");\r\n        }\r\n        \r\n        var taskDateFrom = (DateTime) planData.TaskDateFrom;\r\n        var taskDateTo = (DateTime) planData.TaskDateTo;\r\n\r\n        if (taskDateFrom >= taskDateTo) {\r\n            return ShowError(\"Дата начала должна быть раньше даты окончания\");\r\n        }\r\n \r\n        // считаем все задачи в плане работ за выбранный период\r\n        var allWorks = entities.Workitem.Where(x => x.PlanWork == rootRecordId).Where(x => x.PlannedEndDate > taskDateFrom).Where(x => x.PlannedEndDate <= taskDateTo).Select(x => new { x.id, x.AutoNumber, x.Name, x.PlannedStartDate, x.PlannedEndDate, x.City }).ToList();\r\n        var worksToPrint = entities.Workitem.Where(x => x.PlanWork == rootRecordId).Where(x => x.PlannedEndDate > taskDateFrom).Where(x => x.PlannedEndDate <= taskDateTo).Select(x => new { x.id, x.AutoNumber, x.Name, x.PlannedStartDate, x.PlannedEndDate, x.City }).ToList();\r\n        worksToPrint.Clear();\r\n\r\n        // если нет данных на печать, то нужно вывести сообщение и выйти\r\n        if (allWorks.Count() == 0) {\r\n            return ShowError(\"В указанном периоде нет завершающихся работ в плане\");\r\n        }\r\n \r\n        // если в плане что-то было выбрано галочками, то нужно вывести именно их, другие не выводить\r\n        // получим id всех элементов отмеченных галочкой\r\n        var selectedItems = userCommandContext.SelectedIds.ToList(); \r\n        if (selectedItems.Count() > 0) { \r\n            foreach(var a in allWorks)  {\r\n                if (selectedItems.IndexOf(a.id) >= 0) {\r\n                    worksToPrint.Add(a);\r\n                } \r\n            }\r\n            allWorks = worksToPrint;\r\n        }\r\n\r\n        // соберем коллекцию с городами\r\n        Dictionary<string,string> cities = new Dictionary<string,string>();\r\n        var allCities = entities.CON_City.Select(x => new { x.id, x.Name }).ToList();\r\n        foreach (var singleCity in allCities) {\r\n            cities.Add(singleCity.id, singleCity.Name);\r\n        }\r\n\r\n        // отсортируем все работы по номеру\r\n        allWorks = allWorks.OrderBy(o=>o.AutoNumber, new NaturalSortComparer()).ToList();\r\n\r\n        // соберем итоговую табличку \r\n        var positionsToAdd = new List<ConsTask>();       \r\n\r\n        var lineCounter = 1;\r\n        var totalVolume = TimeSpan.FromMinutes(0);\r\n        double totalCost = 0;\r\n\r\n        var dataToExport = new Task() {};\r\n        TimeSpan durationSum;\r\n\r\n        foreach (var singleWork in allWorks) {\r\n            \r\n            var singlePosition  = new ConsTask() {\r\n                taskNum    = lineCounter.ToString(),\r\n                taskName   = singleWork.Name,\r\n                startDate  = ((DateTime) singleWork.PlannedStartDate).AddHours(5), // добавим 5 часов чтобы видеть то что видит пользователь\r\n                endDate    = ((DateTime) singleWork.PlannedEndDate).AddHours(5)   // добавим 5 часов чтобы видеть то что видит пользователь\r\n            };    \r\n\r\n            // определим город\r\n            if (singleWork.City != null) {\r\n                singlePosition.taskPlace  = cities[singleWork.City];\r\n            } else {\r\n                singlePosition.taskPlace  = null;\r\n            }\r\n\r\n            // определем плановые трудозатраты на данную задачу \r\n            var timesheetPlanList = entities.TimesheetPlan.Where(x => x.Workitem == singleWork.id).Select(x => new { x.Duration }).ToList();\r\n            // посчитаем суммарные плановую трудоемкость на задачу\r\n            durationSum = TimeSpan.Zero;\r\n\r\n\r\n            foreach (var singleTime in timesheetPlanList) {\r\n                durationSum += (TimeSpan) singleTime.Duration;\r\n            }\r\n\r\n            // если не указаны плановые трудозатраты в задаче, то в печать она не выйдет\r\n            if (durationSum == TimeSpan.Zero) {\r\n                continue;\r\n            }\r\n \r\n            // посчитаем количество человеко-часов           \r\n            int tempHours = 24 * durationSum.Days + durationSum.Hours + durationSum.Minutes / 60;\r\n            singlePosition.taskVolume = (Decimal) tempHours;\r\n            totalVolume += durationSum; \r\n            \r\n            // посчитаем стоимость работы - умножим человеко-часы на стоимость одного человеко-часа\r\n            if (singleWork.City == \"816766\" && singlePosition.taskVolume != null) {\r\n                singlePosition.taskCost = singlePosition.taskVolume * planData.Cost_Surgut;             \r\n            } else if (singleWork.City == \"816784\"  && singlePosition.taskVolume != null) {\r\n                singlePosition.taskCost = singlePosition.taskVolume * planData.Cost_Izhevsk;\r\n            } \r\n            \r\n            // посчитаем итоговую стоимость в рублях\r\n            if (singlePosition.taskCost != null) {\r\n                totalCost = totalCost + (double) singlePosition.taskCost;   \r\n            }           \r\n\r\n            positionsToAdd.Add(singlePosition);\r\n            // номер по-порядку\r\n            lineCounter++;\r\n        }\r\n \r\n        // посчитаем итоговое количество человеко-часов \r\n        dataToExport.taskVolumeSum = 24 * totalVolume.Days + totalVolume.Hours + totalVolume.Minutes / 60;\r\n \r\n        // табличка с планом работ готова\r\n        dataToExport.taskPositions = positionsToAdd;      \r\n        \r\n        // посчитаем итоговую стоимость в рублях\r\n        dataToExport.taskCostSum = (Decimal) totalCost;\r\n\r\n        var res=Api.TeamNetwork.ObjectAppExportService.ExecuteWordExportTemplate(userCommandContext.DocumentTemplateId,dataToExport,false);\r\n\r\n        var result = new UserCommandResult {\r\n            Success = true,\r\n            Commited = true,\r\n            File=new UserCommandFileResult() {\r\n                Content=res,\r\n                Name = userCommandContext.FileName + \".docx\",\r\n                Type = \"WORD\"\r\n            },\r\n            ResultType = UserCommandResultType.Notificate,\r\n            Messages = new[] {\r\n                new UserCommandMessage {\r\n                    Severity = SeverityLevel.Normal,\r\n                    Text = \"Документ успешно выгружен\"\r\n                }\r\n            }\r\n        };\r\n\r\n        return result;\r\n    }\r\n\r\n    [Serializable]\r\n    public class Task {\r\n        public Decimal? taskVolumeSum {get; set;}\r\n        public Decimal? taskCostSum {get; set;}\r\n        public List<ConsTask> taskPositions {get; set;}\r\n    }\r\n\r\n    [Serializable]\r\n    public class ConsTask {\r\n        public string taskNum {get; set;}\r\n        public string taskName {get; set;}\r\n        public string taskPlace {get; set;}\r\n        public DateTime? startDate {get; set;}\r\n        public DateTime? endDate {get; set;}\r\n        public Decimal? taskVolume {get ;set;} \r\n        public Decimal? taskCost {get ;set;} \r\n    }\r\n}",
      "Type": "CSharpExpression"
    }
  },
  "RelatedEntityGlobalAlias": {
    "$type": "Comindware.Platform.Contracts.GlobalAlias, Comindware.Platform.Contracts",
    "Type": "ExportTemplate",
    "Owner": "WorkPlan",
    "Alias": "ConsTask"
  },
  "LockStateChangeType": "Undefined",
  "LockStateVisibilityType": "Undefined"
}